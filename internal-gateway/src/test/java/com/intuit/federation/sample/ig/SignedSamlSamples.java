/**
 * (c) 2003-2012 MuleSoft, Inc. This software is protected under international
 * copyright law. All use of this software is subject to MuleSoft's Master
 * Subscription Agreement (or other Terms of Service) separately entered
 * into between you and MuleSoft. If such an agreement is not in
 * place, you may not use the software.
 */

package com.intuit.federation.sample.ig;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.List;
import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import junit.framework.Assert;

import org.junit.BeforeClass;
import org.junit.Test;
import org.opensaml.DefaultBootstrap;
import org.opensaml.saml2.core.Assertion;
import org.opensaml.saml2.core.Attribute;
import org.opensaml.saml2.core.AttributeStatement;
import org.opensaml.saml2.core.EncryptedAttribute;
import org.opensaml.saml2.core.impl.ResponseImpl;
import org.opensaml.saml2.encryption.Decrypter;
import org.opensaml.security.SAMLSignatureProfileValidator;
import org.opensaml.xml.XMLObject;
import org.opensaml.xml.encryption.InlineEncryptedKeyResolver;
import org.opensaml.xml.io.Unmarshaller;
import org.opensaml.xml.io.UnmarshallerFactory;
import org.opensaml.xml.parse.BasicParserPool;
import org.opensaml.xml.security.credential.BasicCredential;
import org.opensaml.xml.security.keyinfo.KeyInfoCredentialResolver;
import org.opensaml.xml.security.keyinfo.StaticKeyInfoCredentialResolver;
import org.opensaml.xml.signature.SignatureValidator;
import org.opensaml.xml.validation.ValidationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

public class SignedSamlSamples {
	
	//
	// There are lots of ways to load your private key for decryption, but for
	// simplicity I'm demonstrating loading from a .p12 file generated by
	// OpenSSL. The following member variables store information related to 
	// use of the private key packaged with this sample.
	// These properties are loaded from the test-gateway.properties file.
	private static String mP12KeystoreFileLocation = null;
	private static char[] mPrivateKeyPassword = null;
	private static char[] mKeystorePassword = null;
	private static String mPrivateKeyAlias = null;
	private static String mKeystoreType = null;
	private static String mDemoSamlFileLocation = null;		// Location of the SAML xml file that these demo methods use.
	private static Properties properties;
	
	/**
	 * Bootstraps the test properties from the test-gateway.properties file.
	 * 
	 * @throws Exception
	 */
	@BeforeClass
	public static void setUp() throws Exception {
		// Initialize the properties
		loadProperties("/test-gateway.properties");
		
		// Look up the keystore properties and fail if they do not exist.
		String val = (String)properties.get("keystore.password");
		if (val == null) {
			throw new Exception("The properties file does not contain keystore.password.");
		}
		mKeystorePassword = val.toCharArray();
		
		val = (String)properties.get("keystore.privateKeyPassword");
		if (val == null) {
			throw new Exception("The properties file does not contain keystore.privateKeyPassword.");
		}
		mPrivateKeyPassword = val.toCharArray();
		 
		mPrivateKeyAlias = (String)properties.get("keystore.privateKeyAlias");
		if (mPrivateKeyAlias == null) {
			throw new Exception("The properties file does not contain keystore.privateKeyAlias.");
		}
		
		mP12KeystoreFileLocation = (String)properties.get("keystore.keystorePath");
		if (mP12KeystoreFileLocation == null) {
			throw new Exception("The properties file does not contain keystore.keystorePath.");
		}
		
		mDemoSamlFileLocation = (String)properties.get("test.SamlFileLocation");
		if (mDemoSamlFileLocation == null) {
			throw new Exception("The properties file does not contain test.SamlFileLocation.");
		}
		
		// Read the keystore type defaulting to JKS
		mKeystoreType = (String)properties.get("keystore.keystoreType");
		if (mKeystoreType == null) {
			mKeystoreType = "JKS";
		}
		
		if (!("JKS".equalsIgnoreCase(mKeystoreType) || "PKCS12".equalsIgnoreCase(mKeystoreType))) {
			throw new Exception("Unsupported keystore type:" + mKeystoreType);
		}
	}

	
	/**
	 * The most basic (though less secure) way to deal with the SAML content.
	 * 
	 * If you don't care about validating the signature or getting at the 
	 * encrypted attribute(s), you can just use xpath to read the SAML and be 
	 * done with it.
	 * 
	 * @throws Exception
	 */
	@Test
	public void demoReadingSamlUsingXPath() throws Exception {
		String expectedResult = "targetUrl-test-value";

		XPath xpath = XPathFactory.newInstance().newXPath();
		String expression = "/Response/Assertion/AttributeStatement/Attribute" +
		"[@Name='targetUrl']/AttributeValue";

		//
		// Parse the XML as a W3C Document
		DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
		Document document = builder.parse(new File(mDemoSamlFileLocation));
		Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);

		// Read the attribute value.
		String receivedValue = node.getTextContent();
		Assert.assertTrue(expectedResult.equals(receivedValue));
	}

	/**
	 * The most common use case involves trying to get the unique identifier
	 * for the user whose identity is being federated. This value is found in
	 * the subject NameId element and represents a pseudonym for Intuit's 
	 * internal IAM AuthId.
	 *  
	 * @throws Exception
	 */
	public void demoFindingUserIdInSaml() throws Exception {
		String expectedResult = "dcb1a5a4-8a4f-411c-9389-8e0db9ff467f";

		XPath xpath = XPathFactory.newInstance().newXPath();
		String expression = "/Response/Assertion/Subject/NameID";

		//
		// Parse the XML as a W3C Document
		DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
		Document document = builder.parse(new File(mDemoSamlFileLocation));
		Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);

		// Read the attribute value.
		String receivedValue = node.getTextContent();
		Assert.assertTrue(expectedResult.equals(receivedValue));
	}

	/**
	 * Alternately, you can use the OpenSAML library to do the heavy SAML 
	 * lifting for you. For simple use cases, this does not provide a lot of 
	 * value. For other use cases, you'll really want to let OpenSAML handle
	 * processing for you.
	 * 
	 * This demo shows how to initialize the library and use it to process and
	 * find the user unique identifier (same value as demoFindingUserIdInSaml
	 * above).
	 * 
	 * @throws Exception
	 * @see {@link #demoFindingUserIdInSaml()}
	 */
	@Test
	public void demoCanLoadThroughOpenSaml() throws Exception {
		String expectedResult = "1c97a8b5-42f7-4d5f-b79c-96015db9adc7";

		//
		// I'm loading the SAML from file here. In an HTTP world you can just
		// grab it from the HTTP request's body. 
		String wireXml = readFileAsString(mDemoSamlFileLocation);
		ResponseImpl samlResponse = null;

		BasicParserPool ppMgr = new BasicParserPool();
		ppMgr.setNamespaceAware(true);

		ByteArrayInputStream bais = new ByteArrayInputStream(wireXml.getBytes());
		Document inCommonMDDoc = ppMgr.parse(bais);

		Element metadataRoot = inCommonMDDoc.getDocumentElement();

		// Initializes OpenSAML to use the default config files packaged inside
		// the opensaml-x.y.z.jar
		DefaultBootstrap.bootstrap();

		UnmarshallerFactory unmarshallerFactory = org.opensaml.xml.Configuration.getUnmarshallerFactory();
		Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(metadataRoot);

		XMLObject xmlObject = unmarshaller.unmarshall(metadataRoot);
		samlResponse = (ResponseImpl) xmlObject;		

		String receivedValue = 
			samlResponse.getAssertions().get(0).getSubject().getNameID().getValue();

		Assert.assertTrue("Expected and Received do not match.", 
				expectedResult.equals(receivedValue));
	}

	@Test
	public void demoDecryptTicketAttribute() throws Exception {
		//
		// Sensitive values to be handled specially
		char[] keyStorePassword = mKeystorePassword;
		char[] privateKeyPassword = mPrivateKeyPassword;
		String privateKeyAlias = mPrivateKeyAlias;

		//
		// XML-Security standard decryption setup. Note that I'm loading from
		// a .p12 file here - you can also load from an X.509 cert if you've 
		// got one in either file format or inside your keystore. As of JDK6,
		// it's easy to import the pkcs file to the Java JKS using the keytool.
		KeyStore ks = KeyStore.getInstance("PKCS12");
		ks.load(new FileInputStream(mP12KeystoreFileLocation), keyStorePassword);

		KeyStore.PasswordProtection pp = 
			new KeyStore.PasswordProtection(privateKeyPassword);

		KeyStore.PrivateKeyEntry entry = 
			(KeyStore.PrivateKeyEntry) ks.getEntry(privateKeyAlias, pp);

		// Sanity check to make sure the PKCS file contains the private key
		if (entry instanceof PrivateKeyEntry) {
			// Good.
		} else {
			Assert.fail("p12 file does not contain private key as expected.");
		}
		PrivateKey pk = entry.getPrivateKey();

		// We need to set the private key on our Credential because the symmetric
		// key was encrypting using our public key. This means we need to *decrypt*
		// it with our private key. 
		BasicCredential c = new BasicCredential();
		c.setPrivateKey(pk);

		KeyInfoCredentialResolver keyResolver = 
			new StaticKeyInfoCredentialResolver(c);

		// The symmetric key is encrypted and placed inside our SAML xml doc. Use
		// this resolver to ensure it gets loaded from the KeyInfo element.
		InlineEncryptedKeyResolver encryptionKeyResolver = new InlineEncryptedKeyResolver();

		Decrypter d = new Decrypter(null, keyResolver, encryptionKeyResolver);
		d.setRootInNewDocument(true);

		//
		// Now that we've got our decryption tool ready to go, we need to load
		// the SAML xml and parse it, searching for the xml element that is
		// encrypted.
		//

		//
		// Parse the whole SAML xml.
		String wireXml = readFileAsString(mDemoSamlFileLocation);
		ResponseImpl samlResponse = null;

		DefaultBootstrap.bootstrap();
		BasicParserPool ppMgr = new BasicParserPool();
		ppMgr.setNamespaceAware(true);

		ByteArrayInputStream bais = new ByteArrayInputStream(wireXml.getBytes());
		Document inCommonMDDoc = ppMgr.parse(bais);

		Element metadataRoot = inCommonMDDoc.getDocumentElement();

		UnmarshallerFactory unmarshallerFactory = org.opensaml.xml.Configuration.getUnmarshallerFactory();
		Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(metadataRoot);

		XMLObject xmlObject = unmarshaller.unmarshall(metadataRoot);
		samlResponse = (ResponseImpl) xmlObject;		

		//
		// Find the encrypted element. Note that only one attribute is 
		// encrypted now - there may be multiple in the future.
		Assertion a = samlResponse.getAssertions().get(0);
		AttributeStatement as = a.getAttributeStatements().get(0);
		List<EncryptedAttribute> eas = as.getEncryptedAttributes();
		for (EncryptedAttribute ea : eas) {

			//
			// Decrypt the encrypted attribute.
			Attribute ticketAttr = d.decrypt(ea);

			//
			// The ticketAttr is now in plain text - verify 
			Assert.assertTrue("ticket".equals(ticketAttr.getName()));

			String samlTicketValue = ticketAttr.getAttributeValues().get(0).getDOM().getTextContent();
			String exampleQBTicket = "4_benemp6bd_bw8nfv_b_bfwcxxgbbqz788dtsavn7dwzas4m_4xxbttv29t7p693tdcg8specdg6hhkzzv9t872hc7p6ra384y3cb_";

			Assert.assertEquals(exampleQBTicket.length(), samlTicketValue.length());
		}
		System.out.println("***************" + mP12KeystoreFileLocation + "****************");
	}
	
	/**
	 * Recipients should always verify the XML signature contained in the SAML
	 * to ensure it came from Intuit as expected.  This demo method shows how
	 * to do this.  Note that the actual public key Credential you should use
	 * depends on the Intuit environment the request is coming from - different
	 * certificates are used for PRODUCTION and other envs. This example uses a 
	 * cert from the Intuit Production Workplace environment. There is also a commented 
	 * out reference to a public key for the Beta workplace environment for developers
	 * who are using that environment.
	 * 
	 * Keep in mind that any trivial changes to the SAML assertion, including
	 * whitespace or line ending changes, will throw the signature validation off. 
	 *  
	 * @throws Exception
	 */
	@Test
	public void demoVerifyingXmlSignature() throws Exception {

		//
		// In this example, the sampleSignedSaml.xml file came from the Intuit
		// PROD environment.  I'll load the appropriate certificate for XML
		// signature verification.
		CertificateFactory cf = CertificateFactory.getInstance("X.509");

		//String e2eCrtFile = "src/main/resources/SAML-beta.workplace.intuit.com.saml.crt";
		String prdCrtFile = "src/main/resources/SAML-workplace.intuit.com.saml.crt";
		
		Certificate intuitCert = cf.generateCertificate(new FileInputStream(prdCrtFile));
		PublicKey pk = intuitCert.getPublicKey();
		
		//
		// OpenSAML uses xml-tooling's infrastructure objects for cryptography
		BasicCredential credential = new BasicCredential();
		credential.setPublicKey(pk);
		
		//
		// I'm loading the SAML from file here. In an HTTP world you can just
		// grab it from the HTTP request's body. 
		String wireXml = readFileAsString(mDemoSamlFileLocation);
		ResponseImpl samlResponse = null;

		BasicParserPool ppMgr = new BasicParserPool();
		ppMgr.setNamespaceAware(true);

		ByteArrayInputStream bais = new ByteArrayInputStream(wireXml.getBytes());
		Document inCommonMDDoc = ppMgr.parse(bais);

		Element metadataRoot = inCommonMDDoc.getDocumentElement();

		// Initializes OpenSAML to use the default config files packaged inside
		// the opensaml-x.y.z.jar
		DefaultBootstrap.bootstrap();

		UnmarshallerFactory unmarshallerFactory = org.opensaml.xml.Configuration.getUnmarshallerFactory();
		Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(metadataRoot);

		XMLObject xmlObject = unmarshaller.unmarshall(metadataRoot);
		samlResponse = (ResponseImpl) xmlObject;

		// The signed object is the Assertion.
		Assertion a = samlResponse.getAssertions().get(0);

		SAMLSignatureProfileValidator profileValidator = new SAMLSignatureProfileValidator();
		try {
		    profileValidator.validate(a.getSignature());
		} catch (ValidationException e) {
		    // Indicates signature did not conform to SAML Signature profile
			Assert.fail("Signature did not conform to SAML XML Signature profile: "+e.getMessage());
		}
		
		SignatureValidator sigValidator = new SignatureValidator(credential);
		try {
		    sigValidator.validate(a.getSignature());
		} catch (ValidationException e) {
			// NOTE: Failure is expected here. See note in method docs for explanation.
			Assert.fail("Unable to validate XML signature of SAML message: "+e.getMessage());
		}		
	}
	
	/**
	 * SAML messages can come from many different sources. Inside Intuit there 
	 * are a number of environments - test and production ones - that could 
	 * potentially originate a SAML message. If you want/need to, use the Issuer
	 * to decide how you want to handle it.
	 *  
	 * @throws Exception
	 */
	@Test
	public void demoHandlingDifferentSamlSources() throws Exception {
		String expectedResult = "IDFED_PROD_IDP_SP_APP";

		XPath xpath = XPathFactory.newInstance().newXPath();
		String expression = "/Response/Assertion/Issuer";

		//
		// Parse the XML as a W3C Document
		DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
		Document document = builder.parse(new File(mDemoSamlFileLocation));
		Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);

		// Read the attribute value.
		String receivedValue = node.getTextContent();
		Assert.assertTrue(expectedResult.equals(receivedValue));
	}

	/**
	 * I don't have an X509 cert handy to prove this out, but this is generally
	 * how it would work if you were using that instead of a PKCS pub/priv file. 
	 *
	 * @throws Exception
	 */
	@Test
	public void demoCredentialsComeFromX509() throws Exception {
//		String alias = "xxx";
//		char[] password = "yyy".toCharArray();
//
//		// ... Load the SAML xml just as above ...
//
//		// Get a reference to the keyStore you want to use (load from file or
//		// use the default JVM one).
//		KeyStore keyStore = null;
//
//		// Find your X509 in the keystore.
//		KeyStore.PrivateKeyEntry keyEntry = 
//			(KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, new KeyStore.PasswordProtection(password));
//
//		X509Certificate certificate = (X509Certificate)keyEntry.getCertificate();
//		BasicX509Credential credential = new BasicX509Credential();
//		credential.setEntityCertificate(certificate);
//		credential.setPrivateKey(keyEntry.getPrivateKey());
//
//		KeyInfoCredentialResolver keyResolver = new StaticKeyInfoCredentialResolver(credential);
//		InlineEncryptedKeyResolver encryptionKeyResolver = new InlineEncryptedKeyResolver();
//
//		Decrypter decrypter = new Decrypter(null, keyResolver, encryptionKeyResolver);
//		decrypter.setRootInNewDocument(true);
//
//		// Decrypt the encrypted XML element you're dealing with
//		EncryptedAttribute encryptedAttribute = null;
//		Attribute assertion = decrypter.decrypt(encryptedAttribute); 			
	}

	/**
	 * Utility method to help in the examples.
	 * 
	 * @param filePath
	 * @return
	 * @throws java.io.IOException
	 */
	private static String readFileAsString(String filePath)
	throws java.io.IOException {
		StringBuffer fileData = new StringBuffer(1000);
		BufferedReader reader = new BufferedReader(
				new FileReader(filePath));
		char[] buf = new char[1024];
		int numRead=0;
		while((numRead=reader.read(buf)) != -1){
			String readData = String.valueOf(buf, 0, numRead);
			fileData.append(readData);
			buf = new char[1024];
		}
		reader.close();
		return fileData.toString();
	}
	
	private static void loadProperties	(String resourceName) throws IOException {
		properties = new Properties();
		InputStream fileInputStream = null;
		try {
			fileInputStream =  SignedSamlSamples.class.getResourceAsStream(resourceName);
			if (fileInputStream != null) {
				properties.load(fileInputStream);
			} else {
				String name = resourceName.substring(1);
				fileInputStream = new FileInputStream(name);
				if (fileInputStream != null) {
					properties.load(fileInputStream);
				} else {
					throw new IOException("Configuration resource " + resourceName + " not found");
				}
			}
		} finally {
			if (fileInputStream != null) {
				fileInputStream.close();
				fileInputStream = null;
			}
		}		
	}

}
